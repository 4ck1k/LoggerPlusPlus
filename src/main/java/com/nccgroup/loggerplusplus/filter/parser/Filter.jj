/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Filter.jj */
/*@egen*/options {
               
    STATIC=false;
                 
                                        
                                    
                           
//    DEBUG_PARSER = true;
}

PARSER_BEGIN(FilterParser)
package com.nccgroup.loggerplusplus.filter.parser;
import com.nccgroup.loggerplusplus.filter.BooleanOperator;
import com.nccgroup.loggerplusplus.filter.Operator;import com.nccgroup.loggerplusplus.filterlibrary.FilterLibraryController;
import java.io.IOException;
import java.io.StringReader;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.HashSet;
import java.util.regex.Pattern;
import com.nccgroup.loggerplusplus.logentry.LogEntryField;
import com.nccgroup.loggerplusplus.logentry.FieldGroup;

public class FilterParser/*@bgen(jjtree)*/implements FilterParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTFilterParserState jjtree = new JJTFilterParserState();

/*@egen*/


    //TODO Better error message for AND / OR ambiguity in filters
    public static ASTExpression parseFilter(String string) throws ParseException {
        FilterParser FilterParser = new FilterParser(new StringReader(string));
        ASTExpression node;
        try{
            node = FilterParser.Filter();
        }catch(Exception e){
            throw new ParseException(e.getMessage());
        }
        VisitorData result = new SanityCheckVisitor().visit(node);
        if(!result.isSuccess()) throw new ParseException(result.getErrorString());
        return node;
    }

    public static void checkAliasesForSanity(FilterLibraryController libraryController, ASTExpression filter) throws ParseException {
        VisitorData result = new AliasCheckVisitor(libraryController).visit(filter);
        if(!result.isSuccess()) throw new ParseException(result.getErrorString());
    }

    private static void throwOperatorAmbiguityException(BooleanOperator op, BooleanOperator other) throws ParseException {
        throw new ParseException(String.format("Cannot mix operators %s, %s. Please use parenthesis to remove ambiguity.", op.getLabel(), other.getLabel()));
    }
}

PARSER_END(FilterParser)

SKIP:  { " " }
TOKEN [IGNORE_CASE]: {
    <EQ: "=" | "==" >
    | <NEQ: "!=" >
    | <GT: ">" >
    | <LT: "<" >
    | <GEQ: ">=" >
    | <LEQ: "<=" >
    | <OR: "|" | "||" | "OR" >
    | <AND: "&" | "&&" | "AND" >
    | <XOR: "^" | "XOR" >
    | <CONTAINS: "CONTAINS" >
    | <IN: "IN" >
    | <BOOLEAN: "TRUE" | "FALSE">
    | <SINGLEQUOTEDSTRING: "'" ("\\" ~[] | ~["\'", "\\"])* "'" >
    | <DOUBLEQUOTEDSTRING: "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >
    | <NUMBER: ("-"|"+")?(<DIGIT>)+("."(<DIGIT>)+)?>
    | <DIGIT: ["0"-"9"] >
    | <REGEXLITERAL_IN_FORWARD_SLASHES: "/\\Q" ("\\" ~["E"] | ~["\\"])* "\\E/" >
    | <REGEX_IN_FORWARD_SLASHES: "/" ("\\" ~[] | ~["/", "\\"])+ "/" >
    | <MATCHES: "MATCHES" >
    | <LPAREN: "(" >
    | <RPAREN: ")" >
    | <INVERSE: "!" | "NOT" >
    | <DOT: "." >
    | <IDENTIFIER: (["a"-"z","A"-"Z","_","0"-"9"])+ >
    | <ARRAY_START: "[" >
    | <ARRAY_END: "]" >
    | <ARRAY_SEPARATOR: ",">
    | <ALIAS_SYMBOL: "#">
}

ASTExpression Filter()       :
{
 ASTExpression ex;
}
{
    ex=Expression(false)<EOF>
    {
        return ex;
    }
}

ASTExpression Expression(boolean inverse)             :
{/*@bgen(jjtree) Expression */
 ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 BooleanOperator op = null;
}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    ExpressionInner() [op=ExpressionCompounding()]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.op = op;
        jjtn000.inverse = inverse;
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void WrappedCompoundExpression()       :
{
    boolean inverse=false;
}
{
    [inverse=Inverse()] <LPAREN> Expression(inverse) <RPAREN>
}

void ExpressionInner()       :
{}
{
    LOOKAHEAD(2) Statement() | WrappedCompoundExpression()
}

void Statement()       :
{
}
{
    Alias() | Comparison()
}

BooleanOperator ExpressionCompounding()       :
{
    BooleanOperator op;
    BooleanOperator nextOp;
}
{
    (op = And() | op = Or() | op = Xor()) ExpressionInner() //First compounding can be any operator
    (
        (nextOp = And() | nextOp = Or() | nextOp = Xor())
        { //Subsequent compoundings must be same operator. Otherwise, throw exception.
            if(op != nextOp) throwOperatorAmbiguityException(op,nextOp);
        }
        ExpressionInner()
    )*

    { return op; }
}

//Comparisons can take two forms (Value) or (value operation value).
//To make interpretation easier, we convert (Value) to (Value operation value) by means of (Value EQUALS TRUE)
void Comparison()            :
{/*@bgen(jjtree) Comparison */
 ASTComparison jjtn000 = new ASTComparison(JJTCOMPARISON);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Operator op = Operator.EQUAL;
 Object left, right = true;
 Boolean value;
}
{/*@bgen(jjtree) Comparison */
    try {
/*@egen*/
    (LOOKAHEAD(3) left = Identifier() | {throw new ParseException("The left side of a comparison must be a field identifier.");})

    //TODO Identifier type checking here

    (
        op = EqualityOperator() (
            right = Value()
        |
            {throw new ParseException("Missing right hand value for comparison \"" + op + "\"");}
        )
    |
        op = NumericOperator() (
            right = Number()
        |
            right = Identifier()
            {
                if(!Number.class.isAssignableFrom(((LogEntryField) right).getType())){
                    throw new ParseException(String.format("Numeric operators cannot be used for field \"%s\" of type \"%s\"", right, ((LogEntryField) right).getType().getTypeName()));
                }
            }
        |
            {throw new ParseException("Missing right hand value for comparison \"" + op + "\"");}
        )
    |
        op = ContainsOperator() (
            right = String()
        |
            right = Number()
        |
            right = Identifier()
        |
            {throw new ParseException("The contains operator can only be used on string and numeric values and identifiers.");}
        )

    |
        op = InOperator() (
            right = Array()
        |
            {throw new ParseException("The in operator must be used on an array. E.g. \"Response.status IN [200, 302, 500]\"");}
        )
    | op = MatchesOperator() (
                                 right = RegexInString()
                             |
                                 right = RegexInForwardSlashes()
                             |
                                {throw new ParseException("The matches operator must have a pattern as its right hand value."); }
                             )
    | //NO OPERATOR OR RIGHT VALUE Default to EQ TRUE
        {
            if(!(left instanceof Boolean || (left instanceof LogEntryField && ((LogEntryField) left).getType().isAssignableFrom(Boolean.class)))){
                //If left isn't a boolean value or field with boolean type
                throw new ParseException(left + " cannot be evaluated as a boolean.");
            }
        }
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.left = left;
        jjtn000.right = right;
        jjtn000.operator = op;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Alias()       :
{/*@bgen(jjtree) Alias */
    ASTAlias jjtn000 = new ASTAlias(JJTALIAS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token identifier;
}
{/*@bgen(jjtree) Alias */
    try {
/*@egen*/
    <ALIAS_SYMBOL> identifier=<IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.identifier = identifier.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Object Value()      :
{
    Object v;
}
{
    (
        LOOKAHEAD(2) v = Identifier()
    |
        v = Number()
    |
        v = Boolean()
    |
        LOOKAHEAD(2) v = String()
    |
        v = RegexInForwardSlashes()
    |
        v = RegexInString()
    )
    {return v;}
}

HashSet Array()      :
{
    HashSet<Object> items = new HashSet();
    Object i;
}{
    <ARRAY_START>
    (
        LOOKAHEAD(2) i=String() {items.add(i);}
        (
            <ARRAY_SEPARATOR> i=String() {items.add(i);}
        )* //String array
    |
        LOOKAHEAD(2) i=Number() {items.add(i);}
        (
            <ARRAY_SEPARATOR> i=Number() {items.add(i);}
        )* //Number array
    )
    <ARRAY_END>

    { return items; }
}

//IDENTIFIERS
LogEntryField Identifier()      :
{
    Token group, identifier;
    FieldGroup fieldGroup;
    LogEntryField field;
}
{
    group=<IDENTIFIER>
    {
    fieldGroup = FieldGroup.findByLabel(group.image);
    if(fieldGroup == null)
        throw new ParseException(String.format("Invalid field group \"%s\". Valid groups are: %s", group.image, Arrays.toString(FieldGroup.values())));
}
    <DOT>
    identifier=<IDENTIFIER>
    {
        field = LogEntryField.getByLabel(fieldGroup, identifier.image);
        if(field == null)
            throw new ParseException(String.format("Invalid field \"%s\". Valid fields for group \"%s\" are: %s", identifier.image, fieldGroup, LogEntryField.getFieldsInGroup(fieldGroup).values()));
        if(field == LogEntryField.NUMBER)
            throw new ParseException("Field " + LogEntryField.NUMBER + " is ephemeral and cannot be used in filters.");
        return field;
    }
}

//END IDENTIFIERS


//TYPES

BigDecimal Number()       :
{Token t;}
{
    t=<NUMBER>
    {return new BigDecimal(t.image);}
}

String String()       :
{Token t;}
{
    ( t=<SINGLEQUOTEDSTRING> | t=<DOUBLEQUOTEDSTRING> )

    {
        String s = t.image.substring(1,t.image.length()-1);
        return org.apache.commons.text.StringEscapeUtils.unescapeJava(s);
    }
}

Pattern RegexInString()       :
{Token t;}
{
    ( t=<DOUBLEQUOTEDSTRING> | t=<SINGLEQUOTEDSTRING> )
    {
        return Pattern.compile(t.image.substring(1,t.image.length()-1), Pattern.CASE_INSENSITIVE);
    }
}

Pattern RegexInForwardSlashes()       :
{Token t;}
{
    ( t=<REGEXLITERAL_IN_FORWARD_SLASHES> | t=<REGEX_IN_FORWARD_SLASHES> )
    {
        return Pattern.compile(t.image.substring(1,t.image.length()-1), Pattern.CASE_INSENSITIVE);
    }
}

Boolean Boolean()       :
{Token t, inverse=null;}
{
    [inverse=<INVERSE>]
    t=<BOOLEAN>
    {
        return (inverse != null ^ Boolean.parseBoolean(t.image));
    }
}

//END TYPES


//BASIC OPERATORS

Operator EqualityOperator()       :
{}
{
      <EQ>  {return Operator.EQUAL;}
    | <NEQ> {return Operator.NOT_EQUAL;}
}

Operator NumericOperator()       :
{}
{
    <GT>  {return Operator.GREATER_THAN;}
    | <LT>  {return Operator.LESS_THAN;}
    | <GEQ> {return Operator.GREATER_THAN_EQUAL;}
    | <LEQ> {return Operator.LESS_THAN_EQUAL;}
}

Operator ContainsOperator()       :
{}
{
    <CONTAINS> {return Operator.CONTAINS;}
}

Operator MatchesOperator()       :
{}
{
    <MATCHES> {return Operator.MATCHES;}
}

Operator InOperator()       :
{}
{
    <IN> {return Operator.IN;}
}

boolean Inverse()       :
{}
{
    <INVERSE> {return true;}
}

BooleanOperator And()       :
{}
{
    <AND> {return BooleanOperator.AND;}
}

BooleanOperator Or()       :
{}
{
    <OR> {return BooleanOperator.OR;}
}

BooleanOperator Xor()       :
{}
{
    <XOR> {return BooleanOperator.XOR;}
}